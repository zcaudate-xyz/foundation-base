(ns code.ai.server
  (:require [org.http-kit.server :as http]
            [std.concurrent.relay :as relay]
            [std.concurrent.bus :as bus]
            [std.lib :as h]
            [clojure.data.json :as json]
            [clojure.edn :as edn])
  (:import (org.httpkit.server AsyncChannel))
  (:refer-clojure :exclude [send]))

(defonce *server* (atom nil))
(defonce *relays* (atom {}))
(defonce channels (atom #{}))

(defn get-channels [] @channels)

(defn send-to-clients [type data]
  (let [message (json/write-str {:type type :data data})]
    (doseq [^AsyncChannel channel (get-channels)]
      (http/send! channel message))))

(defn handle-relay-output [relay-id {:keys [line type]}]
  (send-to-clients :relay/output {:id relay-id :type type :line line}))

(defn create-relay-instance [command]
  (let [id (h/sid "relay-")
        rly (relay/relay:create {:type :process
                               :id id
                               :command command
                               :options {:receive {:custom {:op :custom-line
                                                             :handler (fn [line _] (handle-relay-output id {:line line :type :stdout}))}}
                                         :error   {:custom {:op :custom-line
                                                             :handler (fn [line _] (handle-relay-output id {:line line :type :stderr}))}}}})
                              )]
    (swap! *relays* assoc id rly)
    (h/start rly)
    id))

(defn stop-relay-instance [id]
  (when-let [rly (get @*relays* id)]
    (h/stop rly)
    (swap! *relays* dissoc id)))

(defn get-relay-info [id]
  (when-let [rly (get @*relays* id)]
    (let [{:keys [id type command]} rly
          started? (h/started? rly)]
      {:id id :type type :command command :running started?} )))

(defn ws-handler [request]
  (http/with-channel request channel
    (println "WebSocket channel opened:" channel)
    (swap! channels conj channel)
    
    (http/on-close channel (fn [status]
                             (println "WebSocket channel closed:" channel "status:" status)
                             (swap! channels disj channel)))
    (http/on-receive channel (fn [data]
                               (println "Received WebSocket data:" data)
                               ;; For now, echo back or handle specific requests from frontend
                               (http/send! channel (str "Echo: " data))))))

(defn handler [request]
  (println "Received HTTP request:" request)
  (let [{:keys [uri method body]} request
        parsed-body (some-> body h/->str edn/read-string)]
    (cond
      (= uri "/ws")
      (ws-handler request)

      ;; List all relays
      (and (= uri "/relays") (= method :get))
      {:status 200
       :headers {"Content-Type" "application/edn"}
       :body (pr-str (doall (map get-relay-info (keys @*relays*))))}

      ;; Create a new relay
      (and (= uri "/relays") (= method :post))
      (let [command (:command parsed-body)
            id (create-relay-instance command)]
        {:status 201
         :headers {"Content-Type" "application/edn"}
         :body (pr-str (get-relay-info id))})

      ;; Get relay info
      (and (re-matches #"/relay/.*" uri) (= method :get))
      (let [id (second (h/string-split uri #"/"))]
        (if-let [info (get-relay-info id)]
          {:status 200
           :headers {"Content-Type" "application/edn"}
           :body (pr-str info)}
          {:status 404 :body "Relay not found"}))

      ;; Send input to a relay
      (and (re-matches #"/relay/.*/input" uri) (= method :post))
      (let [id (second (h/string-split uri #"/"))
            input (:input parsed-body)]
        (if-let [rly (get @*relays* id)]
          (do (relay/send rly {:op :raw :line input})
              {:status 200 :body "Input sent"})
          {:status 404 :body "Relay not found"}))

      ;; Stop a relay
      (and (re-matches #"/relay/.*/stop" uri) (= method :post))
      (let [id (second (h/string-split uri #"/"))]
        (if (get @*relays* id)
          (do (stop-relay-instance id)
              {:status 200 :body "Relay stopped"})
          {:status 404 :body "Relay not found"}))

      (= uri "/")
      {:status 200
       :headers {"Content-Type" "text/html"}
       :body "<html><body><h1>Relay Manager Frontend</h1><div id="app"></div><script src="/js/main.js"></script></body></html>"}

      :else
      {:status 404 :body "Not Found"})))

(defn start-server
  "Starts the HTTP server"
  {:added "4.0"}
  ([port]
   (println "Starting HTTP server on port" port)
   (reset! *server* (http/run-server handler {:port port}))))

(defn stop-server
  "Stops the HTTP server"
  {:added "4.0"}
  ([]
   (when @*server*
     (println "Stopping HTTP server")
     (@*server* :timeout 100)
     (reset! *server* nil)
     (doseq [id (keys @*relays*)]
       (stop-relay-instance id)))))

(comment
  (start-server 8080)
  (stop-server)
  )