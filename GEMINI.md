# Learnings

## `code.test` Framework

- **Fact Structure**: Tests are defined using `fact`. Metadata controls execution.
- **Component Injection**: Components like `|rt|` are NOT injected via `:use` or `:let` in the way standard `clojure.test` fixtures might work.
- **Global Components**: `fact:global` defines components that can be accessed in tests.
- **Broken `:use`/`:let`**: The `:use` and `:let` keys in `fact` metadata are stripped out by `fact-thunk` in `src/code/test/compile.clj` and are not functional for binding in the test body.
- **Setup/Teardown**: The correct way to handle per-test setup/teardown is using `:setup` and `:teardown` metadata keys, which can call helper functions.
- **Global State**: `fact:global` can define `:setup` and `:teardown` for the entire namespace, but per-fact isolation requires explicit `:setup`/`:teardown` on the fact itself if not using the global ones.

## `std.scheduler.spawn`

- **Runtime Management**: Spawns are managed within a runtime atom.
- **Testing Spawns**: Tests often require a runtime `|rt|` to be initialized.
- **Clear Operation**: The `clear` function needed to be updated to also remove spawns from the `:running` map, not just `:programs` and `:past`.

## `std.lang` Tests

- **Macro Expansion**: `defstruct.rs` and other macros in `std.lang.model.spec-rust` work correctly in isolation, suggesting previous "Syntax error macroexpanding" issues might have been context-dependent or transient.
- **R Integration**: `std.lang.model.spec-r-test` uses a guard `std.lang.spec.r/CANARY`. If this guard fails (returns false), the tests in that fact are skipped or fail with "Guard failed".

# Exported Memories

- **Grammar Retrieval**: To programmatically retrieve the grammar for a `std.lang` language, use `(:grammar (l/get-book (l/default-library) :<lang-keyword>))`. The grammar is not exposed as a public var.
- **Test Timeouts**: When executing facts with timeouts in `code.test`, `java.util.concurrent.ExecutionException` is caught and unwrapped to re-throw the underlying cause (unless it is a `TimeoutException`), ensuring consistent error reporting between synchronous and asynchronous execution.
- **Context Documentation**: Documentation for `std.lib.context` is located in `plans/std_lib_context/`, including architectural analysis (`analysis.md`), general usage proposals (`proposals.md`), 3D virtual world mappings (`3d_virtual_worlds.md`), the applicative model (`applicative_model.md`), the invoke-as pattern (`invoke_as_patterns.md`), AI agent architecture (`ai_agents.md`), and async evaluation analysis (`async_evaluation.md`).
- **JavaScript Wrappers**: The `src/js` directory contains Clojure files defining standard JavaScript library wrappers (e.g., `js.react`, `js.tamagui`, `js.blessed`) using the `l/script` DSL, rather than raw JavaScript files.
- **DebounceDispatch**: `DebounceDispatch` (`std.dispatch.debounce`) offers three strategies for filtering high-frequency events: `:eager` (executes first, then blocks), `:delay` (waits for a pause, executes last), and `:notify` (executes first, then enforces a cooldown).
- **Console Log Testing**: Tests for `std.log.console` view functions (e.g., `console-status-outcome`) should handle ANSI escape codes in output, often necessitating regex matching or simple type checks (`string?`) instead of exact string equality.
- **Spawn Requirements**: The `std.scheduler.spawn/create-spawn` function requires the program map argument to include a `:create-fn` key.
- **Unchecked Task**: The `code.manage/unchecked` task identifies untested variables by recursively searching (using `flatten`) the test definition's s-expression for the `=>` assertion symbol, ensuring nested checks are detected. It also explicitly excludes facts marked with `^:unchecked` metadata from the report.
- **Dispatch Creation**: The `std.dispatch/create` function requires an `:options` map containing a valid `:pool` configuration (e.g., `{:size 1}`) to pass schema validation.
- **Layout Spacing**: When the indentation level is zero, the `row-spacing` generated by `std.block.layout.common/layout-by` consists of a single newline character without any trailing spaces.
- **Finding Var Tests**: The `indigo.tool.inspect/find-var-tests` function finds tests related to a specific Clojure var by dynamically requiring the corresponding test namespace (e.g., `my.ns` becomes `my.ns-test`), then filtering test vars by checking if the var's source code, retrieved via `h/source-fn`, contains the name of the target var.
- **Project Test Alias**: The `test` alias in `project.clj` is configured as `["run" "-m" "code.test"]`.
- **Heal Namespace**: The namespace `code.heal.core` is defined in `src/code/heal/core.clj` (previously incorrectly named `level.clj`).
- **React Scheduling**: `std.dom.react` implements batched rendering using a `*scheduler*` dynamic variable; updates are queued via `schedule-update` and applied via `flush-updates` to prevent synchronous thrashing.
- **Test Feedback**: The `code.test` framework explicitly invokes `std.lib/beep` to provide audible feedback during test failures (in `listener/check-printer`) and top-level namespace loading errors (in `executive/load-namespace`).
- **Scheduler Install**: Programs passed to `std.scheduler/install` require an `:interval` key for `spawn` operations to succeed.
- **Layout Rules**: The `std.block.layout` library implements custom layout rules: vectors default to single-column, `cond` uses a specific 2-column spec (`:col-from 0`), and `let` bindings use a 2-column spec attached via metadata.
- **Test Diffs**: The `code.test` framework uses `code.test.diff` (backed by `std.lib.collection` and `std.lib.diff.seq`) to generate nested, human-readable diffs for failed assertions in `print-failed`. It explicitly unflattens path-vector keys returned by `std.lib.collection/diff`.
- **Test Timeouts (Metadata)**: The `code.test` framework supports test timeouts for `:core` facts via `^:timeout <ms>` metadata applied to the `fact` form.
- **Test Runner With**: The `code.test` runner accepts the `:with` argument (e.g., `lein test :with std.lang.model.spec-xtalk`) to execute a test suite comprising the main specification test and its related component tests (e.g., `com-js`, `fn-js`).
- **Resource Function**: The `res/res` function in `std.lib.resource` has the signature `(res/res resource-type selector-config [create-config])`. The `selector-config` map identifies an instance, while the optional `create-config` is used only for initial creation.
- **Library State Mutation**: Functions in `std.lang.base.library` that mutate library state (e.g., `delete-book!`, `add-entry-single!`) may return `nil` or arbitrary collections, not consistently vectors or maps, requiring flexible test assertions.
- **Task Reference**: A comprehensive reference for the `std.task` map structure, including top-level keys (`:type`, `:main`, `:item`, `:result`) and sub-configuration, is located in `src/std/task/REFERENCE.md`.
- **3D World Mapping**: In the context of 3D virtual worlds, `std.lib.context` primitives are proposed to map as follows: `Space` to World/Zone, `Context` to Engine/Backend, `Runtime` to Session/Connection, and `Pointer` to Entity/Object.
- **Manage Command Arguments**: Commands run via `lein manage` require arguments to be formatted as EDN strings, specifically expecting a vector for the target namespace (e.g., `'[code.manage]'`) and a map for options (e.g., `'{:write false}'`).
- **Create Tests Task**: The `code.manage` task `create-tests` invokes both `scaffold` (to generate files) and `arrange` (to organize content) for setting up test environments.
- **Timeout Exception Testing**: Tests validating `java.util.concurrent.TimeoutException` from future dereferencing in `code.test` must explicitly convert the `java.util.concurrent.ExecutionException` cause, verify it, and return a value to assert against, as relying on `(throws)` results in a "Thrown" status rather than a pass.
- **No Unsolicited PRs**: Do not submit PRs unless explicitly instructed by the user.
- **Build AST**: To utilize `code.dev.build.build-ast`, the build directory must first be generated using `(std.make/build-all code.dev.build.build-ast/BUILD_AST)`, followed by `(code.dev.build.build-ast/initialise)` to install necessary NPM dependencies.
- **Test Exception Status**: The `code.test` framework uses `{:status :exception}` to identify thrown errors within the executive summary logic.
- **Figma Components**: When using `js.lib.figma` components in `std.lang` scripts, the standard pattern is to alias the library as `fg` and use the registry syntax `[:% fg/ComponentName ...]`. `js.lib.figma` handles component registration automatically.
- **Timeout Execution Thread**: Timeout execution in `code.test` occurs in a separate thread using `std.lib.future`; this requires setting the thread's `ContextClassLoader`, using `bound-fn` for dynamic binding propagation, and explicitly binding `*ns*` to the current namespace to support `eval`.
- **Testing Runtime Functions**: When testing `std.lang` functions that depend on a specific runtime context (like `l/emit-as`), the `code.test` runner may not propagate the context correctly. A reliable pattern is to define a helper function within a namespace that has the necessary `l/script` context, place the context-dependent call inside that helper, and then call the helper function from the `fact` in the test file.
- **Multiline Test Output**: Multi-line test output values (e.g., for `Form`, `Check`, `Eval`) in `code.test.base.print` are formatted using `std.string.prose/indent-rest` to align subsequent lines with the start column of the first line (typically offset by 10 spaces).
- **Letfn Formatting**: `letfn` is included in `std.block.layout.bind/+bindings+` but is explicitly excluded from `layout-annotate` because its vector of function definitions is incompatible with the key-value pair processing used for other binding forms.
- **Indigo Layout**: The `indigo` web application structure separates UI layouts into `src/indigo/webapp/` (e.g., `layout_library_browser.clj`) and client integration logic into `src/indigo/client/` (e.g., `browser_main.clj`).
- **HubDispatch**: `HubDispatch` (`std.dispatch.hub`) acts as a centralized router, grouping events and using a debouncer to trigger batch processing for each group.
- **Code Test Wildcard**: The `code.test` framework treats the symbol `any` (and `'any`) within checker structures (like `contains`) as a wildcard by resolving it to `(satisfies anything)`, preventing equality check failures against the symbol itself.
- **Perl Spec**: `std.lang.model.spec-perl` implements Perl 5 support, handling variable sigils, subroutine argument unpacking via `shift`, and mapping the `concat` operator to `.`.
- **Dispatch Strategies**: The `std.concurrent.dispatch` library provides multiple, composable dispatching strategies built upon a foundational `CoreDispatch` (`std.dispatch.core`) for basic asynchronous execution.
- **Integration Test Data**: Integration test data, such as JSON AST files, is stored in the `test-data` directory, structured to mirror the namespace hierarchy (e.g., `test-data/code.translate` for `code.translate`).
- **Doc Generation**: The `code.doc` library is used for generating documentation websites, configured primarily via `config/publish.edn` and executed through `init-template`, `deploy-template`, and `publish` tasks.
- **Future Exception Handling**: Throwing exceptions directly within a `std.lib.future/on:complete` callback is an anti-pattern as it can crash the underlying executor thread. Errors should be propagated through the future chain or managed within a state atom.
- **JS Map Shorthand**: In `std.lang` JS maps, the `:#` shorthand supports both vectors and single symbols for key shorthand, while explicitly preventing `nil` values from generating "null" keys.
- **Text Index Async**: The `std.text.index` library uses an agent for its in-memory search index, making its operations asynchronous. Tests must use `(await <index-agent>)` to ensure state changes are complete before making assertions.
- **Literate Clojure**: The `code.doc` library implements a 'Literate Clojure' approach by directly parsing the Clojure AST (via `code.doc.parse`) to extract documentation structure and custom directives (e.g., `[[:chapter ...]]`), rather than relying solely on docstrings.
- **Relay Config**: `std.concurrent.relay/relay` configuration maps require a `:type` key (e.g., `{:type :process}`) to function correctly in tests.
- **Build Namespace Mapping**: Namespaces under `code.dev.build` (e.g., `code.dev.build.build-umd`, `code.dev.build.build-ast`) map to individual files within the `src/code/dev/build/` directory (e.g., `build_umd.clj`, `build_ast.clj`) rather than a single `build.clj` file.
- **Std Lang Transpiler**: The `std.lang` framework functions as a transpiler converting a Lisp-like DSL into target languages (JS, Lua, Python, etc.) using a central 'Book' structure (`std.lang.base.book`) for language definitions.
- **UI Vision**: The user's vision for the UI tool is a 'System Explorer' with a 'Limited Interaction Philosophy'. The tool should be for viewing, browsing, and composing functionalities, not a general-purpose code editor.
- **Collection Library**: The project should use `std.lib.collection` instead of `clojure.data` for collection operations and diffing.
- **Pointer Wrapper**: The `with:rt-wrap` macro in `std.lang.base.pointer` unquotes its function argument (`~f`) within the generated `binding` form to ensure correct variable resolution.
- **Stream Model**: The `std.lib.stream` library should use an iterator/lazy-sequence model for processing, not a transducer-based model.
- **JS DSL Translation**: The `code.translate.js-dsl` namespace translates JavaScript `SpreadElement` and `RestElement` AST nodes into `...` and `&` symbols respectively, and `UpdateExpression` nodes to `(++ ...)` or `(-- ...)` forms.
- **Module Globals**: The `std.lang.base.script-lint/collect-module-globals` function ensures `h/union` operations receive and return sets (using `or ... #{}`) to prevent `NullPointerException`s when processing empty modules.
- **Tempfile Path**: The `std.fs.api/create-tmpfile` function returns a `java.io.File`, while many functions in `std.fs.path` (like `set-executable`) expect a `java.nio.file.Path`, requiring explicit conversion in tests (e.g., `(path/path ...)` or `.toPath`).
- **Board Dispatch Tests**: Tests for `std.dispatch.board/new-board` must dereference the returned atom to verify its content, as the function returns an atom containing the board state.
- **Java Version**: The development environment requires Java 21.
- **Bus Library**: The `std.concurrent.bus` library provides an in-process, thread-based messaging system for asynchronous, one-to-one communication between different parts of an application.
- **Startable Primitive**: The `std.lib.future-start/startable` primitive executes its underlying task only once. Subsequent invocations or dereferences return the cached result (either success or error) from the initial run.
- **Queue Tests**: Tests for `std.concurrent.queue` must explicitly convert the queue to a vector (e.g., `(vec q)`) before asserting equality with vector literals, as `LinkedBlockingDeque` is not equal to a Clojure vector.
- **Factory Pattern**: For startable asynchronous primitives, a multi-use 'factory' design is preferred. This pattern separates the task definition (the factory) from its execution (which produces a new future on each call), maximizing composability. Single-use behavior can be implemented as a layer on top of the factory.
- **Macro Operators**: To treat standard Clojure macro symbols (like `->`) as operators in a `std.lang` grammar, they must be explicitly reserved (e.g., via `grammar/build:extend` with `:symbol #{'-> ...}`) and potentially excluded from the default macro set to prevent expansion during script processing.
- **Tailwind Render**: The `std.tailwind/render` function translates Tailwind sizing classes (e.g., `w-4`) into character units (typically 1rem = 4 chars) for ASCII output.
- **Atom Queues**: `std.concurrent.atom` implements `aq` and `hub` as atom-based, lock-free batching queues, offering an alternative to the blocking JUC queues found in `std.concurrent.queue`.
- **Resource Lifecycle**: The `std.lib.resource` library provides lifecycle management for components via specifications that define `:type`, `:mode` (`:global`, `:namespace`, `:shared`), and instance functions (`:create`, `:setup`, `:teardown`).
- **Test Checkers**: The `=>` operator in `code.test` generates checkers with the `:satisfies` tag; `code.test.diff` extracts the expected value from these checkers to support diffing.
- **Postwalk Intern**: The `std.lib.walk` namespace provides `postwalk`, which is interned into `std.lib`, allowing `std.lib/postwalk` to be used for traversing code forms.
- **JS Imports**: When using `std.lang`'s `l/script` macro, external JavaScript libraries (e.g., Monaco, React Live) should be included via the `:import` directive, not `:require`.
- **Resource Idempotency**: In `std.lib.resource`, the `res` function idempotently retrieves an active resource or creates a new one based on a given ID, while functions like `res:start` and `res:stop` manage its lifecycle.
- **Protocol Testing**: When testing protocol methods (e.g., `std.protocol.component/-info`) in `code.test`, `with-redefs` may be ineffective; using `reify` to implement the protocol on the test subject is recommended.
- **Rewrite Metadata**: The `code.test.compile.rewrite` namespace preserves form metadata during AST rewriting by applying `with-meta` to rewritten lists, ensuring macros dependent on `&form` (like `code-line`) function correctly within tests.
- **Execution Environment**: The execution environment does not support Docker or `clojure`/`clj` CLI tools; manual Leiningen installation is required for all tasks.
- **Std Lib Central**: The `std.lib` namespace (`src/std/lib.clj`) serves as a central aggregation point for core utilities, requiring and exposing functions from sub-namespaces like `std.lib.collection`, `std.lib.string`, `std.lib.future`, and `std.lib.map`.
- **Single NS Test**: To run tests for a single namespace and avoid timeouts, use the command `./lein run -m code.test :only <namespace-name>`.
- **JS DSL Nodes**: The `code.translate.js-dsl` namespace supports translating complex JavaScript AST nodes including `TryStatement` (to `try`), `SwitchStatement` (to `case`), `ForOfStatement` (to `for` with `:of`), `ClassDeclaration`, and destructuring patterns into their `std.lang` equivalents.
- **Indigo Server**: A development server, `indigo`, is defined in `src/indigo/server.clj`. It runs on port 1311 and integrates tools from `code.test`, `code.doc`, and `code.manage`, along with a custom `inspect-var` tool for introspecting Clojure variables.
- **Manage Task Entry**: The `code.manage` namespace exposes tasks via a `-main` entry point that uses a variadic signature `[& [cmd & args]]` to destructure command-line arguments (which `lein run` passes individually), resolving tasks dynamically via `ns-resolve` and converting arguments with `read-string`.
- **Test File Mods**: When modifying existing test files, ensure that original comment forms and `fact` stubs are preserved, avoiding wholesale overwrites that delete context.
- **Dynamic Script Runtime**: In `std.lang`, the execution runtime is dynamically bound to the namespace where `l/script` is defined. To allow functions to be used across different namespaces and adopt the caller's runtime, the `l/script` macro can be given a `:dynamic true` flag. This makes all functions defined within that script resolve their runtime at the call site.
- **Task Refactor Goal**: The user has an architectural goal to refactor the `std.task` library to be built on the `std.lib.stream.async` library, representing a task as a composable stream pipeline (`Source` -> `Pipeline` -> `Sink`).
- **UI Mockup**: The user has instructed to build a UI mockup using `js.lib.figma` components and to ignore server-side errors related to `monaco` and `live` imports for the time being, as they will fix the frontend manually.
- **Scheduler Mock**: In `std.scheduler.common` tests, the `runner` argument is mocked as a map `{:runtime (atom {:running ...})}` to simulate the internal state of active programs.
- **DOM Sync**: The `std.dom.sync` namespace implements a synchronization protocol where `ISyncServer` provides `generate-diff` (taking a `last-synced-dom` baseline) and `get-snapshot` to manage state updates between decoupled DOM trees.
- **Doc Template Keys**: The `init-template` function in `code.doc` requires converting site keyword keys to strings (e.g., `(str/to-string site)`) to correctly create and locate template paths compatible with `deploy-template`.
- **Invoke-As Pattern**: The `invoke-as` pattern in `std.lib.apply` allows an object to determine its own execution context (Runtime) at the moment of invocation via `resolve-runtime`, subsequently delegating to `apply-in`.
- **Local Scripts**: Locally installed scripts, such as Leiningen, are not in the system's PATH and must be executed using a relative path (e.g., `./lein`).
- **Layout Estimate**: Functions in `std.block.layout.estimate` (e.g., `estimate-multiline-basic`) return a boolean indicating whether a form requires multiline layout, determined by checking if its width exceeds a `:readable-len` (defaulting to `*readable-len*` or metadata).
- **MCP Tool Definitions**: MCP tool definitions in `mcp-clj` require detailed strings for the `:description` key and argument descriptions in `:inputSchema` to effectively guide the LLM client.
- **CI Environment**: The CI environment (defined in `.github/workflows/run-test.yml`) uses the `ghcr.io/zcaudate-xyz/infra-foundation-clean:ci` image, where `lein` is available on the system PATH (invoked as `lein`), unlike the local dev environment which uses `./lein`.
- **Script Macro Intern**: The `std.lang.base.script-macro/intern-in` function handles non-keyword tags by using `str` instead of `name` to prevent `NullPointerException`s.
- **String Namespace**: The `std.string` namespace defines its own string utilities (e.g., `includes?`) and does not automatically refer `clojure.string`; consumers should alias it (e.g., `[std.string :as str]`) to use these functions.
- **Grammar Override**: In `std.lang` grammar definition, `grammar/build:override` requires the key to exist in the base map; if a key is absent (e.g., explicitly excluded), `grammar/build:extend` must be used instead.
- **Test Use Keyword**: The `code.test` framework does not support the `:use` keyword for component injection within `fact` forms; `component/with` or standard `let` bindings should be used instead.
- **Naming Convention**: Clojure files use spinal-case naming, and namespaces strictly follow the directory structure (e.g., `std.lib.collection`).
- **Memoize Test**: The `std.lib.memoize/registered-memoizes` test requires its check to be flexible, using `(any nil? coll?)` instead of `seq?` to handle different collection types (like maps) that may be returned during test reporting.
- **Pretty Print Cycle**: The pretty-printing library, `std.pretty`, can cause a `StackOverflowError` when printing objects with circular references (e.g., a `defrecord` containing an atom that refers back to a collection of records). The correct fix is to implement general cycle detection within the pretty-printer by tracking a set of visited objects, rather than adding a specific handler for `clojure.lang.IRecord`.
- **Relay Bridge**: The `std.concurrent.relay` library acts as a bridge between the internal `std.concurrent.bus` messaging system and external I/O streams, such as sockets or subprocesses.
- **Concurrent Tests**: The `code.test` framework is unreliable for testing concurrent operations (e.g., with `std.dispatch`), often producing cryptic "unknown error" messages. Such tests may need to be simplified or removed to ensure a stable build.
- **Executor Pool Size**: `std.concurrent.executor/executor:single` initializes with a maximum pool size of 1; increasing the core pool size (`exec:pool-size`) requires increasing the maximum pool size (`exec:pool-max`) first to prevent an `IllegalArgumentException`.
- **Layout Bindings**: The `std.block.layout.bind` namespace defines formatting rules via `+bindings+` (for let-like forms) and `+defs+` (for def-like forms) sets.
- **Visual Docs**: The user prefers high-level architectural documentation that includes visual diagrams (e.g., ASCII art) and comprehensive code examples to illustrate how different components work together.
- **Block Metadata**: When constructing blocks with metadata in `std.block.construct`, the tag inference logic validates potential tags against `base/*container-limits*` to avoid treating arbitrary metadata keys (like `:spec`) as block types.
- **Complex Test File**: The test file `test/code/query/traverse_test.clj` is particularly complex and has been a source of persistent, hard-to-debug test failures, especially concerning zipper-related syntax and logic.
- **Xtalk Perl**: The `xtalk` implementation for Perl (`std.lang.model.spec-xtalk.fn-perl`) uses the symbol naming convention `x:<group>-<name>` (e.g., `x:m-abs`) and `x:<name>` (e.g., `x:len`), mapping them to native Perl functions like `abs` and `scalar`.
- **Dispatch Skip Hook**: The `on-skip` hook is used by dispatch strategies like `DebounceDispatch` to signal that a submitted task has been intentionally ignored or filtered, incrementing a `:skip` counter for monitoring purposes.
- **Compile Test Failures**: The `code.test.compile-test` test suite has pre-existing failures, specifically an "Unable to resolve symbol: strip" error. These are not considered regressions.
- **Test Global Timeout**: The `code.test` framework supports a global execution timeout via the `:timeout` argument (in milliseconds) passed to the task runner (e.g., `:timeout 1000`), which wraps test execution in a `std.lib.future`.
- **Install Leiningen**: Leiningen must be installed manually using: `curl -O https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein && chmod +x lein`.
- **JQ Model**: The implementation of the JQ language model resides in `src/std/lang/model/spec_jq.clj` and includes support for basic operators, control flow (`if`, `reduce`, `foreach`, `try`), definitions (`def`), and specific JQ constructs like field access and invocation.
- **Dispatch Executor Lifecycle**: Tests using `std.dispatch` must manage executor lifecycle carefully; specifically, `await-termination` can reset the executor reference to nil, causing `stop-dispatch` to throw a `NullPointerException` during teardown if not handled.
- **DOM Library**: The `std.dom` library (located in `src/std/dom`) is a generic Virtual DOM implementation capable of diffing and patching arbitrary data trees, making it suitable for infrastructure-as-code state management.
- **Task Defaults**: `std.task` defaults missing `:construct` keys (`:input`, `:env`, `:lookup`) to safe no-ops (e.g., `(constantly nil)`) to prevent runtime errors during execution.
- **Standalone Scripts**: Standalone Clojure scripts can be executed within the project's classpath using `./lein exec -p <script-path>`. This is useful for creating minimal reproductions of bugs outside the main test framework.
- **Book Entry Types**: The `std.lang` book model distinguishes between entry types, such as `:code` for functions and `:fragment` for macros, which are created with different helper functions (e.g., `create-code-base` vs. `create-macro`).
- **Language Book Tests**: Tests in `std.lang` that retrieve specific language books (e.g., `l/get-book ... :xtalk`) must explicitly require the namespace defining that book (e.g., `std.lang.model.spec-xtalk`) to ensure it is registered in the default library.
- **Definvoke Macro**: The `definvoke` macro from `std.lib.invoke` must be explicitly referred from `std.lib`. It requires a type-and-config vector (e.g., `[:fn {}]`) as an argument to define a standard function; otherwise, a `ClassCastException` may occur during macroexpansion.
- **Bulk Task Keys**: The `std.task.bulk` library (specifically `std.task.bulk`) automatically maps result columns to keys in the output data if explicit `:keys` mappings are omitted, simplifying task definition.
- **RT Space**: The `std.lang/rt:space` function retrieves the runtime object (verifiable with `rt/rt-default?`) for a language within a specific namespace, not the space object itself.
- **Bus Status Tests**: Tests for `std.concurrent.bus` status (e.g., `info-bus`) must wait for the bus thread to start (e.g., polling `started?-bus`) after initialization via `bus:with-temp` or `start-bus` to avoid race conditions.
- **Lib Module Alias**: In `std.lang`, the function `manage/lib-module-overview` is exposed via the alias `lib:module`.
- **Pointer Map Tests**: To create a valid pointer map for unit tests in `std.lang`, use `std.lang.base.util/lang-pointer` (or `ut/lang-pointer`), as the `l/ptr` macro returns a function (macro expansion result) rather than the map itself.
- **Indigo App**: The `indigo` namespace contains a web application built with a ClojureScript-like DSL (`std.lang` for JS/React) and served by an `http-kit` server located at `src/indigo/server.clj`.
- **Require File Task**: The `require-file` task, defined in `code.manage` and implemented in `code.manage.unit.require`, loads a namespace using `clojure.core/require` and returns a sorted vector of its public var symbols.
- **Src Extra**: The `src-extra` directory acts as a source root for namespaces like `mcp-clj`, despite being listed under `:resource-paths` in `project.clj`.
- **Code Manage API**: The `code.ai.server` namespace exposes `code.manage` tasks via HTTP endpoints `/manage/tasks` (GET) and `/manage/:task` (POST), allowing execution of maintenance tasks.
- **Dispatch Behavior**: The behavior of dispatchers in `std.concurrent.dispatch` is heavily influenced by the underlying executor type (`:single`, `:pool`, `:cached`) which can be configured to control concurrency and execution order (e.g., sequential vs. parallel).
- **Documentation Locations**: Detailed documentation for agent setup, testing, `std.lang`, app development, and configuration is maintained in `plans/jules_setup.md`, `plans/test_summary.md`, `plans/std_lang_summary.md`, `plans/app_dev_workflow.md`, and `plans/std_config_summary.md`.
- **Virtual Executor**: The `std.concurrent.executor/executor:virtual` function uses reflection to create a `newVirtualThreadPerTaskExecutor`, ensuring compatibility with JDKs older than 21 while enabling Virtual Threads on JDK 21+.
- **Build Utilities**: The project utilizes `std.make` (via `make/build`, `make/run`) for build automation and `code.dev` for development utilities, including grouped test runners like `test:base`, `test:infra`, `test:app`, and helper functions like `tests-in-wrong-file`.
- **Clone Default Library**: The `std.lang.base.impl/clone-default-library` function returns a new library instance initialized with the snapshot of the current default library, enabling isolated testing of scripts that depend on existing language definitions.
- **JS Var to Let**: In `std.lang` to JavaScript compilation, `var` declarations typically default to `let` in the output, which means roundtrip translation (DSL -> JS -> AST -> DSL) will result in `(let ...)` forms instead of `(var ...)`.
- **Applicable Protocol**: The `std.lib.apply` library implements the `IApplicable` protocol to decouple execution logic from the environment, allowing operations to be executed within a specific `Runtime` (context) via `apply-in` or with an auto-resolved context via `apply-as`.
- **Tailwind Lib**: The `std.tailwind` library (namespace `std.tailwind`, file `src/std/tailwind.clj`) implements a Tailwind CSS class parser and an ASCII wireframe renderer for Hiccup forms, supporting layout primitives like flexbox, grid, and sizing.
- **Context Macro**: The `code.test.base.context/with-context` macro is the primary mechanism for running code within a temporary, isolated test context, which is essential for testing the framework itself.
- **Lookup NS**: The `code.project/lookup-ns` function enforces that file paths are stored and returned as strings, ensuring compatibility with consumers expecting string paths (like `lookup-path`).
- **Iterative Fixes**: When fixing test files, follow an iterative workflow: fix each file individually and ensure its tests pass before proceeding to the next file.
- **Pool Dispose**: The `std.concurrent.pool/pool:dispose-over` function requires a resource ID as the second argument.
- **Manage Tooling Guide**: The user guide for `code.manage` tooling, detailing usage and available commands (like `analyse`, `scaffold`, `grep`), is located in `plans/manage_tooling.md`.
- **Manage MCP Args**: The `code-manage` MCP tool requires its `args` parameter to be an EDN-encoded string representing a vector, where target namespaces must be specified as symbols (e.g., `"['code.manage]"`), not strings.
- **Refactor Format**: `code.refactor.base.format` implements code formatting utilities (whitespace cleanup, blank line management) and structural alignment (key alignment, sorting, indentation) using `code.query.walk` and `std.block` libraries (`layout`, `grid`).
- **Startable Self-Aware**: The `std.lib.future-start/startable` primitive is self-aware; its thunk receives a context map containing a reference to the startable instance itself under the key `:instance` (e.g., `(fn [{:keys [instance]}] ...)`).
- **JQ Tests**: Tests for the JQ language model are located in `test/std/lang/model/spec_jq_test.clj`.
- **Messaging Architecture**: Architectural documentation for messaging strategies (`bus` and `relay`) is located in `MESSAGING_STRATEGIES.md`.
- **AI Agent Mapping**: In the context of AI Agents, `std.lib.context` primitives are proposed to map as follows: `Space` to Agent Memory/State, `Context` to LLM Provider/Brain, `Runtime` to Session/Thread, and `Pointer` to Tool/Skill.
- **MCP Implementation**: The `mcp-clj` (Model Context Protocol) implementation resides in `src-extra/mcp_clj`.
- **Dynamic Var Access**: In Clojure, dynamic vars should be accessed directly by their symbol (e.g., `*context*`). Incorrectly using the dereference reader macro (`@*context*`) can lead to `ClassCastException`s if the var holds a non-dereferenceable object.
- **Executor Introspection**: `std.concurrent.executor` introspection functions (`executor:info`, `executor:type`) support generic `ExecutorService` instances (such as Virtual Thread executors) by falling back to basic information when `ThreadPoolExecutor` casting fails.
- **Lang MCP Server**: The `std.lang` MCP server can be started using `lein run -m mcp-clj.std-lang-server`.
- **Stream Implementation**: The stream processing implementation in `std.lib.stream` is iterator-based, using lazy sequences. The core transformation functions are defined in `src/std/lib/stream/iter.clj` and mapped to keywords in the `*transforms*` atom in `src/std/lib/stream.clj`.
- **Config Exceptions**: `std.config.resolve/ex-config` constructs and returns a `clojure.lang.ExceptionInfo` object, while `std.config.resolve/resolve-directive-error` throws it.
- **AI Server Tools**: The `code.ai.server` namespace uses a modular tool architecture, aggregating functionality from `code.ai.server.tool.*` namespaces including `basic` (echo/ping), `std-lang` (transpilation/introspection), `code-heal`, `code-test`, `code-doc`, and `code-manage`.
- **Heal Namespace Fix**: The namespace `code.heal` is an incorrect dependency reference in several files; the correct namespace is `std.block.heal`.
- **Lazy Sequence Tests**: When testing functions that produce lazy sequences with side-effects (e.g., `i:peek`), the sequence must be fully realized (e.g., using `doall`) for the side-effects to occur and be asserted against.
- **Fact Context**: The `code.test` `fact` macro evaluates tests in an isolated namespace context, making it difficult to test functions that rely on modifying and reading global, namespace-scoped state like `*ns*`.
- **Nested Fact Context**: The `code.test` framework handles nested `fact` execution in isolated contexts (`with-new-context`) by checking the global registry root (`.getRawRoot #'rt/*registry*`) when a fact ID is not found in the local dynamic registry, copying it over if found.
- **Netty Dependency**: To resolve `java.lang.NoSuchMethodException: java.nio.DirectByteBuffer.<init>(long,int)` on Java 21 with `[com.impossibl.pgjdbc-ng/pgjdbc-ng "0.8.9"]`, the project must explicitly depend on a newer Netty version (e.g., `[io.netty/netty-all "4.1.118.Final"]`) and exclude the outdated transitive Netty modules from `pgjdbc-ng`.
- **Testing Macro Defns**: Testing macros that generate `defn` forms (e.g., `gen-spawn`, `gen-spawn-all`) requires using `eval`. The test should `eval` a `do` block that first calls the macro with unquoted arguments and then checks for the created var (e.g., `(eval '(do (gen-spawn [my-var my-fn]) (var my-var)))`).
- **Source Layout**: The `foundation-base` source layout distinguishes between `src/std` (general-purpose standard libraries like `lib`, `lang`, `concurrent`) and `src/code` (development tooling and framework infrastructure like `manage`, `test`, `doc`).
- **Dev Server Issues**: Starting the development server can fail due to non-obvious, pre-existing dependency issues. These have included incorrect namespace requires (`code.heal`) and missing transitive dependencies (`js.react.ext_monaco`). These may require specific fixes or workarounds to get the server running.
- **Key Docs**: Key documentation and style guides are located in `GEMINI.md` and the `plans/slop/top-level/` directory.
- **Test Exception Categories**: The `code.test` framework classifies exceptions thrown during check verification (e.g., when the input form throws an error) as 'Thrown' errors with the full exception data, distinct from 'Failed' assertions.
- **Test Maintenance**: Directives for test file maintenance: fill out untested forms, add documentation for TODO forms, and delete `fact` forms for variables missing from the source. Valid `fact` forms and metadata must be preserved.
- **Refactor Namespace**: The namespace `code.refactor` houses refactoring tasks (e.g., `replace-usages`) moved from `code.manage`, but these are currently commented out and non-functional due to missing underlying implementations and dependencies (e.g., `lint` namespace).
- **Test Exit Code**: The `code.test` task runner calculates the process exit code by summing the counts of `:failed`, `:thrown`, and `:timeout` tests. The summation safely handles cases where these keys are missing from the results map by treating them as zero.
- **Concurrent Lib Arch**: The `std.concurrent` library architecture prioritizes wrapping `java.util.concurrent` primitives and using a component-based lifecycle (`start`, `stop`) over Clojure's standard `core.async` channels.
- **Use Dispatch**: Use `std.dispatch` for parallel execution instead of generic executors or `pmap`.
- **Print Executor**: The `std.concurrent.print` namespace uses a global, asynchronous executor for printing. This can cause race conditions during application or test suite shutdown, leading to hangs if the print queue is not flushed before the process exits.
- **Nested Assertions**: The `=>` test operator in `code.test.compile` supports nested assertions (e.g., inside `let`, `do`) via a rewrite mechanism in `code.test.compile.rewrite` which transforms them into runtime checks, while preserving the "Parent Form" context for failures.
- **Dispatch Hooks Counter**: The `std.dispatch.hooks/counter` map includes `:poll`, `:skip`, and `:batch` keys in addition to standard lifecycle keys to support all dispatch hooks.
- **Spawn Form Tests**: Tests for `std.scheduler.common` functions that use `resolve` (like `spawn-form`) require dummy target functions to be defined at the top level of the test namespace to be resolvable.
- **Async Stream Lib**: The `std.lib.stream.async` library provides a reactive programming model with `Mono` (a stream of at most one item) and `Flux` (a stream of many items) for building asynchronous, stream-based data processing pipelines.
- **CI Scripts**: The user prefers using Bash scripts (e.g., `scripts/test_changed.sh`) for CI/CD workflow orchestration logic (like file change detection) rather than embedding it entirely within Clojure code.
- **Repo Purpose**: The repository `foundation-base` is a Clojure-based project focusing on `std.lang` for multi-language integration.
- **Logger Component**: `BasicLogger` in `std.log.core` does not implement `std.protocol.component/IComponent`, rendering `std.lib/start` effectively a no-op; tests must explicitly call `logger-start` to initialize the executor and `logger-stop` to prevent thread leaks.
- **Dispatch Hooks**: The `std.concurrent.dispatch` library provides a system of lifecycle hooks (e.g., `:on-submit`, `:on-queued`, `:on-skip`, `:on-error`) that can be configured under the `:hooks` key to monitor and extend dispatcher behavior.
- **Layout Cond**: The `cond` form is explicitly handled in `std.block.layout/layout-spec-fn` with `{:columns 2 :col-from 0}` rather than using the generic `+pairing+` set, ensuring correct indentation for test/expression pairs.
- **Wait Ready Args**: The `rt.basic.server-basic/wait-ready` function accepts arguments in the order `[lang id]`, distinct from other functions that might take `[id lang]`.
- **Rewrite Seq Check**: The `code.test.compile.rewrite` namespace uses `seq?` to detect list-like forms during AST rewriting but explicitly returns `quote` forms as-is to prevent rewriting nested checks within literals.
- **Library Reset**: The `std.lang.base.impl/default-library:reset` function stops the library instance bound to `*library*` or a provided override argument; if neither is present, it stops the global `:hara/lang.library` resource.
- **JS Graphics Libs**: The `src/js/lib` directory contains wrappers for 3D graphics libraries, including `three.clj` (Three.js) and `r3_*.clj` (React Three Fiber ecosystem).
- **Jules Client**: The namespace `code.ai.jules` provides a client for the Google Jules API (`https://jules.googleapis.com`), utilizing `net.http.client` for requests and `X-Goog-Api-Key` for authentication.
- **Figma Lib**: The `js.lib.figma` namespace provides a rich set of pre-built UI components based on the Figma UI library, suitable for creating mockups and production UIs.
- **JS DSL Translation**: The `code.translate.js-dsl` namespace translates Babel/ESTree AST nodes into `std.lang` JavaScript DSL forms.
- **JSX Self-Closing**: The `emit-jsx-inner` function in `std.lang.model.spec-js.jsx` generates self-closing tags (e.g., `<div />`) when the element has no children.
- **ASCII Box Model**: The `std.tailwind` ASCII renderer implements a simplified box model that respects `box-sizing: border-box`, where border width reduces the available width for children.
- **Block Classification**: The `std.block.base` namespace defines block classification via `*block-types*` (e.g., `:token`, `:container`) and grouping via `*container-tags*` (e.g., `:collection`, `:macro`), which inform validity checks.
- **Unit Doc Tools**: The `code.manage.unit` namespace implements functions like `import` (imports unit tests as docstrings) and `purge` (removes docstrings and metadata) to manage inline test documentation.
- **Form Definition**: The `std.lib.collection/form?` function excludes symbols, treating only lists, cons, and lazy-seqs as forms.
- **Emit Script Preference**: When testing `std.lang` models, `l/emit-script` is preferred over `l/emit-as` for generating statements (e.g., `defn`, `struct`, `if`) because `l/emit-as` evaluates in an expression context which restricts the usage of reserved statement tokens.
- **JS Verification**: A verification pipeline for `std.lang` JavaScript generation involves emitting JS code via `std.lang/emit-as`, generating a JSON AST using `code.dev.build.build-ast/generate-ast`, and translating the AST back to DSL using `code.translate.js-dsl/translate-node` to verify roundtrip fidelity.
- **Dispatch Docs**: Comprehensive documentation on `std.dispatch` strategies (`Core`, `Queue`, `Debounce`, `Hub`, `Board`), including code examples and executor combinations, is located in `DISPATCH_STRATEGIES.md`.
- **Tailwind Analysis**: The `std.tailwind.analysis` namespace provides functionality (`estimate-layout`) to parse `std.lang` React DSL code (e.g., `defn.js` forms), converting component calls into Hiccup structures for visualization via `std.tailwind`.
- **Test Files Arg**: The `code.test` runner supports a `:files` argument (space-separated string) to execute tests for specific files. `code.test.task/resolve-files` handles the mapping: test files are run directly, and source files are mapped to their corresponding test namespaces using `code.project`.
- **For Async Transformer**: The `tf-for-async` transformer in `std.lang.model.spec-js` transpiles `for:async` loops into `Promise` chains (`.then`), distinct from native `async/await` syntax.
- **Doc Assets**: `code.doc` theme resources (e.g., CSS, JS) are stored in `resources/assets/code.doc/theme/`, and theme definitions in `src/code/doc/theme/` must reference these paths.
- **JSON Read Keyword**: The `std.json/read` function requires `std.json/+keyword-mapper+` as the second argument to parse JSON objects with keyword keys; otherwise, it defaults to string keys.
- **Refactoring Lib**: Common Clojure refactorings (e.g., `if-not`, `when-not`, `if-to-when`) are implemented in `code.refactor.base.expression`, which utilizes `code.query/modify` for AST transformations.
- **Timeseries Multimethods**: Multimethods in `std.timeseries.common`, such as `sampling-fn` and `sampling-parser`, are designed for extension. Tests should verify their default behavior for unknown dispatch values (e.g., throwing an `IllegalArgumentException` or returning `nil`) rather than assuming implementations for all values.
- **AQ Submit**: `std.concurrent.atom/aq:submit` accepts arguments `[executor queue options]`, where `executor` is an executor service (e.g., `exe/executor:single`).
- **Test Args Parsing**: The `code.test.task/process-args` function parses command-line arguments into a map (e.g., `{:only "ns"}`) instead of a set, to support key-value pairs like `:only <ns>`.
- **Test Checker Object**: The `code.test.base.listener/summarise-verify` function extracts the full `Checker` object into the summary map (key `:checker`), enabling the reporting layer to access original expectations (like `contains` maps) for diffing.
- **Board Dispatch**: `BoardDispatch` (`std.dispatch.board`) is a specialized strategy for managing task dependencies and resource locking, ensuring that tasks requiring access to a shared resource group are processed sequentially for that resource.
- **Nested Failure Context**: Failed nested checks in `code.test` display the 'Parent Form' in the test output to provide context for the failure.
- **Ansi Style Arity**: The `std.print.ansi/style` function requires two arguments (content and style map); calling it with one argument results in an `ArityException`.
- **Pattern Zipper**: The `pattern-zip` function in `code.query.traverse` returns a `std.lib.zip.Zipper`, which is incompatible with the standard `clojure.zip` library. Operations on this zipper must use functions from `std.lib.zip`.
- **Test Context Var**: The `code.test` framework's runtime state is managed via a central, dynamic var `code.test.base.context/*context*`. This var holds a `Context` record containing state like the test registry, accumulator, and evaluation flags, enabling isolated test execution.
- **Vector Layout**: Vectors in `std.block.layout` default to single-column layout; binding vectors (e.g., in `let`) must have `{:spec {:columns 2 :col-align true}}` metadata explicitly attached to retain two-column formatting.
- **Dependency Management**: The project uses Leiningen (`project.clj`) for dependency management and testing.
- **Config Directives**: The `std.config` library manages configuration using EDN data structures with dynamic directives like `[:env]`, `[:global]`, `[:project]`, `[:file]`, and `[:encrypted]` (via `std.config.secure`) to resolve values at runtime.
- **Compile Rewrite**: `code.test.compile/split` is replaced by `code.test.compile/rewrite-top-level`, which takes a list of forms and arrows and converts them into operation maps for `code.test.base.process`.
- **Test Filenames**: Test files must always end in `_test.clj`, and their namespaces must strictly align with the file path (e.g., `test/scratch/foo_test.clj` must define `scratch.foo-test`).
- **Test Summary Logic**: The `code.test` summary and detailed reporting logic explicitly distinguish 'Timeout' errors as a separate category from 'Thrown' and 'Failed' errors, facilitating clearer diagnosis of slow or hanging tests.
- **DOM Sync Testing**: `std.dom.sync` logic (e.g., `sync-step`) can be tested using standard Clojure maps to represent DOM nodes instead of `std.dom.common.Dom` records to avoid `ClassCastException` or protocol resolution issues in isolated test environments.
- **Test Framework Mandate**: The user explicitly mandates using `code.test` instead of `clojure.test` for all testing.
- **Build Config**: Project build configurations are defined using the `def.make` macro (found in `std.make`), which specifies project tags, output directories, and build sections.
- **C Spec**: The `std.lang.model.spec-c` namespace implements C language generation, including support for pointers (`*`, `&`, `->`), structs, enums, typedefs, and typed function definitions.
- **Nix DSL**: The `rt.nix.script` DSL generates Nix configuration by mapping Clojure maps/vectors to attribute sets/lists and supports tagged vectors for special constructs: `[:fn args body]` for functions (e.g., `[:fn [:pkgs :...] ...]`), `[:with scope body]` for `with` expressions, and `[:path "./..."]` for paths.
- **Modify Zipper**: The `code.query/modify` function operates on a zipper, accepting a selector vector and a handler function; the handler receives the matched zipper location (`zloc`) and must return a modified zipper, often using `code.edit/replace`.
- **Line Number Meta**: Line number resolution for assertions in `code.test` prioritizes the input form's metadata but uses the arrow symbol's (`=>`) metadata as a fallback to correctly support simple values (like numbers or symbols).
- **Resource Alias**: Functions in the `std.lib.resource` namespace, whether direct (`res-spec-add`) or templated (`res:start`), must be called with a namespace qualifier (e.g., `(res/res-spec-add ...)` when aliased as `res`) to avoid symbol resolution errors.
- **Jules Mock**: Tests for `code.ai.jules` mock `net.http.client/request` using `with-redefs` to return static responses for `get-sources`, `create-session`, and other API functions.
- **DOM Signal**: The `std.dom.signal` namespace defines a transport abstraction for DOM sync, wrapping payloads as either `:delta` (for DOM operations) or `:event` (for client actions).
- **Queue Recursion**: The 1-arity implementations of `std.concurrent.queue` functions (e.g., `take-first`) must invoke the underlying Java method (e.g., `.takeFirst`) directly to avoid infinite recursion.
- **Make Build All**: The `std.make/build-all` function generates all artifacts (e.g., `package.json`, `index.js`) defined in a `def.make` target, which is useful for initializing build environments within tests.
- **Return Library**: The `std.lib.return` library abstracts over synchronous values and `CompletableFuture`s (via `std.lib.future`) using the `IReturn` protocol and `return-chain` function, enabling unified handling of sync and async execution flows.
- **Query Patterns**: In `code.query` patterns, using `^:? _` for optional trailing elements triggers the automatic insertion of a `_` placeholder if the element is missing; `& _` should be used instead to match optional elements without forcing structural changes.
- **String Join**: The `std.string.wrap/join` function takes the separator as its first argument and the collection as its second: `(join separator collection)`.
- **Log State Tests**: Tests modifying global state in `std.log.common` (e.g., `set-level!`) must utilize `try/finally` blocks to restore original values, ensuring test isolation.
- **Hub Cache**: `HubDispatch` (`std.dispatch.hub`) uses a Guava `Cache` for managing active groups, enabling automatic eviction of unused groups to prevent memory leaks.
- **Fact Helper**: Defining helper functions that wrap `code.test/fact` macros often results in compilation syntax errors; checking logic involving facts should generally be inlined.
- **Perl Strings**: Perl language tests in `std.lang` use `{:string {:quote :double}}` for string emission.
- **Executor Shutdown**: Tests creating `std.concurrent.executor` instances must ensure explicit shutdown (e.g., via `try/finally` or `component/stop`) to prevent thread leaks in the test environment.
- **Tailwind Hiccup**: The `std.tailwind.analysis/to-hiccup` function processes vector inputs by mapping itself over the elements, treating the vector as a sequence of forms rather than a single Hiccup node, and does not normalize the output (e.g., by inserting missing attribute maps).
- **Test Print Alignment**: Test output in `code.test.base.print` uses right-aligned, padded labels (e.g., "Info", "Form", "Diff") for consistent visual alignment.
- **Lang Module Dependencies**: Tests for `std.lang` modules that depend on other modules (e.g., `js.react`) within an isolated library (via `with:library`) must explicitly load those dependencies using `(require '[namespace] :reload)` within the `with:library` scope to ensure they register into the isolated instance.
- **Book Config**: Instantiating a `std.lang.base.book/book` requires providing both `:meta` and `:grammar` keys in its configuration map.
- **Result Record Assertions**: When using `code.test` to assert on functions that return `std.lib.result/Result` records, direct comparison with map literals or matchers like `contains` can fail. A reliable method is to destructure the result record and assert on its individual keys and values (e.g., `(let [[k v] @output] (and (= k 5) (= (:status v) :return) ...))` ).
- **Pipeline Architecture**: An architectural overview illustrating how to compose `Relay`, `Bus`, `Dispatcher`, and `async` streams into a visual data pipeline is documented in `CONCURRENT_PIPELINES.md`.
- **Running Tests**: Running the full test suite (`lein test`) frequently times out. To run a specific test namespace, use `lein test :only <ns>` (e.g., `lein test :only std.lib.foundation`). When running a group of namespaces, use `lein test :in std.lib`
- **RT Mocks**: Tests for `rt.*` namespaces (e.g., `rt.postgres`, `rt.redis`, `rt.solidity`) must mock external connections and processes using `with-redefs` or verify code emission, as the environment does not support running these services.
- **Lang Install in Tests**: Tests for `std.lang` runtime control functions (e.g., in `std.lang.base.script-control`) require the target language to be explicitly installed (e.g., via `rt/install-lang!`) within the test namespace to populate the necessary context and registry entries.
- **Map Refactoring**: `align-keys` and `sort-keys` refactorings utilize `std.block.layout.common/layout-multiline-hashmap` to format map blocks, ensuring consistent alignment and sorting according to library standards.
- **Queue Dispatch**: `QueueDispatch` (`std.dispatch.queue`) is a strategy for high-throughput scenarios that processes tasks in configurable batches rather than individually.
- **Runner Start**: Before calling `std.scheduler/spawn` or `std.scheduler/unspawn`, the runner's executors must be started via `runner:start`.
- **Log Macros**: The macros `std.log/with-indent` and `std.log/with-overwrite` contain implementation errors (missing unquotes and incorrect namespace references) that prevent them from compiling if used.
- **Throws Workaround**: In `code.test`, if the `(throws)` matcher fails to catch an expected exception (specifically `clojure.lang.ExceptionInfo` in certain contexts) and reports it as 'Thrown' instead of 'Passed', a reliable workaround is to wrap the call in a `try/catch` block and return a specific keyword (e.g., `:thrown`) to assert against.
- **Emit As Runtime**: Using `l/emit-as` in tests requires the target module to be successfully registered; if the module's `l/script` block contains runtime configuration (e.g., `:runtime :jdbc.client`) that fails to initialize, module resolution will fail.
- **Diff Keys**: `std.lib.collection/diff` returns difference maps with flat, path-vector keys (e.g., `{[:a :b] val}`) instead of nested maps.
- **Pretty Print Failures**: The `code.test` framework uses `std.pretty` to print test failure reports. When a test fails, it attempts to pretty-print the actual values involved in the assertion.
- **Getting Started**: The project documentation includes a `GETTING_STARTED.md` file containing detailed installation, usage (REPL), development setup instructions, and specific guides for key libraries (`std.lib`, `std.lang`, `std.concurrent`, `std.json`, `std.string`, `code.test`).
- **Doc Plugin Tags**: `code.doc.engine.plugin.api/entry-tag` replaces dots with underscores in namespace and variable names (e.g., `code.core` -> `code_core`) when generating HTML IDs.
- **Install Artifacts**: Installing `foundation-base` requires running `lein install` to publish artifacts to the local `~/.m2` repository, as Clojars deployment is currently paused.
- **Run Check Logic**: To verify `code.test.base.process/run-check` behavior, tests must explicitly bind `code.test.base.runtime/*eval-mode*` and provide specific metadata to control the skip/run logic, as it relies on global dynamic state.
- **Rewrite Path**: The `code.test` framework uses a dynamic variable `code.test.compile.rewrite/*path*` to propagate source file paths to nested checks (e.g., within `let` forms) during macro expansion, preventing lost filename metadata.
- **YAML Write**: The `script.yaml/write` function defaults to flow style (e.g., `{key: value}`) rather than block style for simple maps unless specific `DumperOptions` are provided.
- **Context Library**: The `std.lib.context` library implements a context/runtime system via `registry` (definitions), `space` (lifecycle/state), and `pointer` (references), governed by `std.protocol.context`.
- **Executor Types**: The `std.concurrent.executor` namespace provides core executor types for thread management: `:single`, `:pool`, `:cached`, `:scheduled`, and `:virtual` (Java 21+ Virtual Threads).
- **Executor String**: The string representation for `java.util.concurrent.ThreadPoolExecutor` instances is customized by `executor-string` to print basic information (type, identity hash code) and avoid calling complex internal functions. This prevents potential hangs when executors are printed during test failures.
- **MCP Tools**: The `code.ai.server.tool.std-lang` namespace implements MCP tools: `std-lang-list` (list languages), `std-lang-modules` (list modules), and `lang-emit-as` (transpile code).
- **Task Eval**: Code passed as a string to a task must be evaluated. Use `(eval (read-string ...))` to execute a form read from a string.
- **Doc Gen Sequence**: To generate a `code.doc` site, use the following sequence in `lein exec`: `(use 'code.doc) (init-template :site-key {:write true}) (deploy-template :site-key {:write true}) (publish :site-key {:write true})`.
- **Placeholder Tests**: For functions that are difficult to unit test due to environmental side effects (e.g., `std.lang/force-reload`, `std.lang/rt:space`), adding a placeholder test with a comment explaining the testing challenges is an acceptable practice.
- **Emit As Macro**: When using `std.lang/emit-as` to test statement-generating macros (like those containing `return` or `var` declarations), wrap the form in a vector (e.g., `['(fn [] ...)]`) within the `emit-as` call to prevent "reserved token" errors in the transpiler.
- **Test Structure**: The project's test file structure can be nested; for example, tests for the `code.test` module are located within the `test/code/test/` directory, not directly in `test/code/`.
- **Console Log Require**: Tests for `std.log.core` that utilize default loggers (which default to console) must explicitly require `std.log.console` to register the necessary multimethod dispatch, as `std.log.core` does not strictly require it.
- **Runtime Variables**: The `code.test.base.runtime` namespace manages the state and configuration of the testing framework through a set of dynamic variables. Key variables include `*eval-*` flags for controlling evaluation context, `*registry*` and `*accumulator*` for data/result management, and `*run-id*`, which serves as a unique UUID to identify a specific test run.
- **Doc Architecture**: The `code.doc` rendering architecture distinguishes between 'engines' (logic, e.g., `winterfell`) and 'themes' (presentation, e.g., `bolton`, `stark`), using `std.html` for Hiccup-based HTML generation.
- **Test Framework**: The project uses a custom testing framework (`code.test`) where tests are defined using the `fact` macro (using `=>` for assertions).
- **Task Main**: The `code.test.task/-main` function passes the parsed arguments map as the second argument to `run` (i.e., `(run target args)`), enabling access to flags like `:only` and `:exit` in `rt/*settings*`.
- **Retry Pattern**: A robust pattern for testing asynchronous retry logic is to use an explicit promise. The test should create a promise, trigger the retry chain, and have the chain complete the promise on success. The test then dereferences this single promise, avoiding issues with nested futures from composition.
- **Test Bindings**: Defining global vars using `def` within `code.test` `fact` blocks causes scope and binding issues; use `let` or `component/with` for local bindings instead.
- **Lein Aliases**: Tests are executed using `lein` with aliases defined in `project.clj` (e.g., `test`, `test-unit`).
- **Match Records**: Functions in `code.query.match.impl`, such as `actual-pattern` and `eval-pattern`, return a record. Tests must access the `:expression` key of the returned record to retrieve the value for comparison.
- **React DSL**: React components in `std.lang` are defined using macros like `defn.js` and explicit `(return ...)` forms, with component instantiation represented as list forms (e.g., `(T/Stack ...)` or `div ...)`).
- **Indigo API**: Backend endpoints for the `indigo` System Explorer are located in `indigo.server.api-browser` and exposed via `/api/translate/browser/` routes (e.g., `namespaces`, `components`).
- **MCP Args**: MCP tools within `code.ai.server` (such as `code-heal`, `code-test`, `code-manage`) typically require arguments (like `params`, `args`, `site`) to be provided as EDN-encoded strings to support Clojure data structures.
- **Reify Methods**: When implementing `clojure.lang.IDeref` or `clojure.lang.IFn` via `reify`, the method names must be `deref` and `invoke` respectively, not `_deref` or `-invoke`.
- **Doc Engine Patch**: The `code.doc.engine/engine` function was patched to use the map key `k` (instead of value `v`) when keywordizing entries, ensuring function values are correctly associated in the output map instead of being keyed by `nil`.
- **JNI Crashes**: Tests under `rt.jep` and `rt.graal-test` are known to cause fatal JVM `SIGSEGV` crashes due to JNI errors (e.g., in `jni_GetArrayLength`). These tests may need to be skipped to allow the rest of the test suite to run.
- **Make Bulk Name**: The `std.make.bulk/make-bulk` function requires the `:name` key in its arguments map to prevent a `NullPointerException` during log formatting.
- **Matchwalk Insertion**: When performing insertion operations during `code.query.walk/matchwalk` traversal, predicates must verify the right sibling (e.g., `zip/right-element`) or otherwise ensure the zipper advances past the insertion to prevent infinite recursion.
- **MCP Guidelines**: Comprehensive guidelines, tool schemas, and agent workflows (e.g., Exploration, Modification) for `code.ai.server` MCP clients are documented in `plans/mcp_client_guidelines.md`.
- **Test Changed Script**: The `scripts/test_changed.sh` script facilitates selective testing in CI by using `git diff` to identify changed `.clj` files and passing them to `lein test` via the `:files` argument.
- **Scaffold Append**: When generating or modifying test files, the return value of `code.manage.unit.scaffold/scaffold-append` must be used to ensure the namespace declaration is correctly included.
- **Trace Lib**: The `std.lib.trace` namespace provides runtime tracing. `trace-ns` instruments all functions in a namespace, and `get-trace` retrieves the call history (a list of maps with `:in` and `:out` keys) from a function var's metadata.
- **Emit As Regex**: The `std.lang/emit-as` function returns the transpiled source code string; tests should use regex (via `h/match?` or implied by `=>`) to verify the presence of expected tokens rather than relying on exact string equality.
- **Library Isolation**: To test destructive `std.lang` library operations safely (like `default-library:reset`), use `std.lang.base.impl/with:library` with a fresh library instance (e.g., `(with:library [(lib/library {})] ...)`), avoiding interference with the global `:hara/lang.library` resource.
